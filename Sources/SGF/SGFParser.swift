// This file is automatically generated by Citron version 2.0.
//
// The parser class defined below conforms to the CitronParser protocol
// defined in CitronParser.swift. 
// 
// The authors of Citron disclaim copyright to the source code in this file.

// Parser class

class SGFParser: CitronParser {

    // Types

    typealias CitronSymbolNumber = UInt8
    typealias CitronStateNumber = UInt8
    typealias CitronRuleNumber = UInt8

    enum CitronTokenCode: CitronSymbolNumber {
      case OPEN_PARENTHESIS               =   1
      case CLOSE_PARENTHESIS              =   2
      case SEMICOLUMN                     =   3
      case PROP_INDENT                    =   4
      case OPEN_BRACKET                   =   5
      case CLOSE_BRACKET                  =   6
      case VALUE                          =   7
      case COLUMN                         =   8
    }

    enum CitronNonTerminalCode: CitronSymbolNumber {
      case value                          =   9
      case c_value_type                   =  10
      case prop_value                     =  11
      case prop_value_list                =  12
      case property                       =  13
      case property_list                  =  14
      case node                           =  15
      case sequence                       =  16
      case gametree                       =  17
      case gametree_list                  =  18
      case collection                     =  19
      case output                         =  20
    }

    enum CitronSymbolCode : RawRepresentable, Equatable {
        case token(CitronTokenCode)
        case nonterminal(CitronNonTerminalCode)
        case endOfInput

        init(_ token: CitronTokenCode) { self = .token(token) }
        init(_ nonterminal: CitronNonTerminalCode) { self = .nonterminal(nonterminal) }
        init(rawValue: CitronSymbolNumber) {
            if (rawValue == 0) {
                self = .endOfInput
            } else if (rawValue < 9) {
                self = .token(CitronTokenCode(rawValue: rawValue)!)
            } else if (rawValue < 21) {
                self = .nonterminal(CitronNonTerminalCode(rawValue: rawValue)!)
            } else {
                fatalError()
            }
        }

        typealias RawValue = CitronSymbolNumber
        var rawValue: CitronSymbolNumber {
            switch (self) {
            case .token(let t): return t.rawValue
            case .nonterminal(let nt): return nt.rawValue
            case .endOfInput: return 0
            }
        }
    }

    typealias CitronToken = SGFToken

    enum CitronSymbol {
        case yyBaseOfStack
        case yy0(CitronToken)
        case yy3([SGFCValueType])
        case yy9((String, [SGFCValueType]))
        case yy10(String)
        case yy15(SGFNode)
        case yy23([SGFNode])
        case yy33(SGFCValueType)
        case yy35([(String, [SGFCValueType])])

        func typeErasedContent() -> Any {
            switch (self) {
            case .yyBaseOfStack: fatalError()
            case .yy0(let value): return value as Any
            case .yy3(let value): return value as Any
            case .yy9(let value): return value as Any
            case .yy10(let value): return value as Any
            case .yy15(let value): return value as Any
            case .yy23(let value): return value as Any
            case .yy33(let value): return value as Any
            case .yy35(let value): return value as Any
            }
        }
    }

    typealias CitronResult = [SGFNode]

    // Counts

    let yyNumberOfSymbols: Int = 21
    let yyNumberOfStates: Int = 16

    // Action tables

    let yyLookaheadAction: [(CitronSymbolNumber, CitronParsingAction)] = [
/*   0 */  (17, .SH( 9)), ( 5, .SH(10)), (19, .SH(15)), (20, .ACCEPT),   ( 1, .SH( 8)),
/*   5 */  ( 2, .SR( 3)), (17, .SH( 7)), (18, .SH(14)), (11, .SH( 2)), (12, .RD(15)),
/*  10 */  (11, .SH( 2)), (12, .RD(13)), ( 1, .SH( 8)), (13, .SH( 4)), (14, .RD(12)),
/*  15 */  (17, .SH( 7)), (18, .RD( 6)), (13, .SH( 4)), (14, .RD(10)), ( 4, .SH( 3)),
/*  20 */  (15, .SH( 6)), (16, .RD( 8)), (15, .SH( 6)), (16, .SH( 1)), ( 3, .SH( 5)),
/*  25 */  (17, .SH( 9)), (10, .SH(13)), (19, .RD( 2)), ( 6, .SR(16)), ( 7, .SH(12)),
/*  30 */  ( 7, .SR(19)), ( 6, .SR(17)), ( 8, .SH(11)), ( 2, .SR( 4)), ( 0, .RD( 0)),
    ]

    let yyShiftUseDefault: Int = 35
    let yyShiftOffsetMin: Int = -4
    let yyShiftOffsetMax: Int = 34
    let yyShiftOffset: [Int] = [
        /*     0 */    11,    3,   -4,   -4,   15,   15,   21,   11,   21,   11,
        /*    10 */    22,   23,   24,   25,   31,   34,
    ]

    let yyReduceUseDefault: Int = -18
    let yyReduceOffsetMin: Int =   -17
    let yyReduceOffsetMax: Int =   16
    let yyReduceOffset: [Int] = [
        /*     0 */   -17,  -11,   -3,   -1,    0,    4,    5,   -2,    7,    8,
        /*    10 */    16,
    ]

    let yyDefaultAction: [CitronParsingAction] = [
  /*     0 */  .ERROR , .ERROR , .RD(14), .ERROR , .RD(11),
  /*     5 */  .RD( 9), .RD( 7), .RD( 5), .ERROR , .RD( 1),
  /*    10 */  .ERROR , .ERROR , .RD(18), .ERROR , .ERROR ,
  /*    15 */  .ERROR ,
    ]

    // Fallback

    let yyHasFallback: Bool = false
    let yyFallback: [CitronSymbolNumber] = []

    // Wildcard

    let yyWildcard: CitronSymbolNumber? = nil

    // Rules

    let yyRuleInfo: [(lhs: CitronSymbolNumber, nrhs: UInt)] = [
        (lhs: 20, nrhs: 1),
        (lhs: 19, nrhs: 1),
        (lhs: 19, nrhs: 2),
        (lhs: 17, nrhs: 3),
        (lhs: 17, nrhs: 4),
        (lhs: 18, nrhs: 1),
        (lhs: 18, nrhs: 2),
        (lhs: 16, nrhs: 1),
        (lhs: 16, nrhs: 2),
        (lhs: 15, nrhs: 1),
        (lhs: 15, nrhs: 2),
        (lhs: 14, nrhs: 1),
        (lhs: 14, nrhs: 2),
        (lhs: 13, nrhs: 2),
        (lhs: 12, nrhs: 1),
        (lhs: 12, nrhs: 2),
        (lhs: 11, nrhs: 2),
        (lhs: 11, nrhs: 3),
        (lhs: 10, nrhs: 1),
        (lhs: 10, nrhs: 3),
    ]

    // Stack

    var yyStack: [(stateOrRule: CitronStateOrRule , symbolCode: CitronSymbolNumber, symbol: CitronSymbol)]  = [
        (stateOrRule: .state(0), symbolCode: 0, symbol: .yyBaseOfStack)
    ]
    var maxStackSize: Int? = nil
    var maxAttainedStackSize: Int = 0

    // Tracing

    var isTracingEnabled: Bool = false
    let yySymbolName: [String] = [
    /*  0 */ "$",
    /*  1 */ "OPEN_PARENTHESIS",
    /*  2 */ "CLOSE_PARENTHESIS",
    /*  3 */ "SEMICOLUMN",
    /*  4 */ "PROP_INDENT",
    /*  5 */ "OPEN_BRACKET",
    /*  6 */ "CLOSE_BRACKET",
    /*  7 */ "VALUE",
    /*  8 */ "COLUMN",
    /*  9 */ "value",
    /* 10 */ "c_value_type",
    /* 11 */ "prop_value",
    /* 12 */ "prop_value_list",
    /* 13 */ "property",
    /* 14 */ "property_list",
    /* 15 */ "node",
    /* 16 */ "sequence",
    /* 17 */ "gametree",
    /* 18 */ "gametree_list",
    /* 19 */ "collection",
    /* 20 */ "output",
    ]
    let yyRuleText: [String] = [
        /*   0 */ "output ::= collection(a)",
        /*   1 */ "collection ::= gametree(a)",
        /*   2 */ "collection ::= gametree(a) collection(b)",
        /*   3 */ "gametree ::= OPEN_PARENTHESIS sequence(a) CLOSE_PARENTHESIS",
        /*   4 */ "gametree ::= OPEN_PARENTHESIS sequence(a) gametree_list(b) CLOSE_PARENTHESIS",
        /*   5 */ "gametree_list ::= gametree(a)",
        /*   6 */ "gametree_list ::= gametree(a) gametree_list(b)",
        /*   7 */ "sequence ::= node(a)",
        /*   8 */ "sequence ::= node(a) sequence(b)",
        /*   9 */ "node ::= SEMICOLUMN",
        /*  10 */ "node ::= SEMICOLUMN property_list(a)",
        /*  11 */ "property_list ::= property(a)",
        /*  12 */ "property_list ::= property(a) property_list(b)",
        /*  13 */ "property ::= PROP_INDENT(a) prop_value_list(b)",
        /*  14 */ "prop_value_list ::= prop_value(a)",
        /*  15 */ "prop_value_list ::= prop_value(a) prop_value_list(b)",
        /*  16 */ "prop_value ::= OPEN_BRACKET CLOSE_BRACKET",
        /*  17 */ "prop_value ::= OPEN_BRACKET c_value_type(a) CLOSE_BRACKET",
        /*  18 */ "c_value_type ::= VALUE(a)",
        /*  19 */ "c_value_type ::= VALUE(a) COLUMN VALUE(b)",
    ]

    // Function definitions

    func yyTokenToSymbol(_ token: CitronToken) -> CitronSymbol {
        return .yy0(token)
    }

    func yyInvokeCodeBlockForRule(ruleNumber: CitronRuleNumber) throws -> CitronSymbol {
        switch (ruleNumber) {
        case 0: /* output ::= collection(a) */
            func codeBlockForRule00(a: [SGFNode]) throws -> [SGFNode] {
    return a
 }
            if case .yy23(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy23(try codeBlockForRule00(a: a))
            }
        case 1: /* collection ::= gametree(a) */
            func codeBlockForRule01(a: SGFNode) throws -> [SGFNode] {
    return [a]
 }
            if case .yy15(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy23(try codeBlockForRule01(a: a))
            }
        case 2: /* collection ::= gametree(a) collection(b) */
            func codeBlockForRule02(a: SGFNode, b: [SGFNode]) throws -> [SGFNode] {
    return [a] + b
 }
            if case .yy15(let a) = yySymbolOnStack(distanceFromTop: 1),
               case .yy23(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy23(try codeBlockForRule02(a: a, b: b))
            }
        case 3: /* gametree ::= OPEN_PARENTHESIS sequence(a) CLOSE_PARENTHESIS */
            func codeBlockForRule03(a: SGFNode) throws -> SGFNode {
    return a
 }
            if case .yy15(let a) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy15(try codeBlockForRule03(a: a))
            }
        case 4: /* gametree ::= OPEN_PARENTHESIS sequence(a) gametree_list(b) CLOSE_PARENTHESIS */
            func codeBlockForRule04(a: SGFNode, b: [SGFNode]) throws -> SGFNode {
    var node = a
    while node.children.count > 0 {
        node = node.children[0]
    }
    node.children.append(contentsOf: b)
    return a
 }
            if case .yy15(let a) = yySymbolOnStack(distanceFromTop: 2),
               case .yy23(let b) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy15(try codeBlockForRule04(a: a, b: b))
            }
        case 5: /* gametree_list ::= gametree(a) */
            func codeBlockForRule05(a: SGFNode) throws -> [SGFNode] {
    return [a]
 }
            if case .yy15(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy23(try codeBlockForRule05(a: a))
            }
        case 6: /* gametree_list ::= gametree(a) gametree_list(b) */
            func codeBlockForRule06(a: SGFNode, b: [SGFNode]) throws -> [SGFNode] {
    return [a] + b
 }
            if case .yy15(let a) = yySymbolOnStack(distanceFromTop: 1),
               case .yy23(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy23(try codeBlockForRule06(a: a, b: b))
            }
        case 7: /* sequence ::= node(a) */
            func codeBlockForRule07(a: SGFNode) throws -> SGFNode {
    return a
 }
            if case .yy15(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy15(try codeBlockForRule07(a: a))
            }
        case 8: /* sequence ::= node(a) sequence(b) */
            func codeBlockForRule08(a: SGFNode, b: SGFNode) throws -> SGFNode {
    a.children.append(b)
    return a
 }
            if case .yy15(let a) = yySymbolOnStack(distanceFromTop: 1),
               case .yy15(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy15(try codeBlockForRule08(a: a, b: b))
            }
        case 9: /* node ::= SEMICOLUMN */
            func codeBlockForRule09() throws -> SGFNode {
    return SGFNode()
 }
            return .yy15(try codeBlockForRule09())
        case 10: /* node ::= SEMICOLUMN property_list(a) */
            func codeBlockForRule10(a: [(String, [SGFCValueType])]) throws -> SGFNode {
    let node = SGFNode()
    for (k, v) in a {
        node.properties[k] = v
    }
    return node
 }
            if case .yy35(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy15(try codeBlockForRule10(a: a))
            }
        case 11: /* property_list ::= property(a) */
            func codeBlockForRule11(a: (String, [SGFCValueType])) throws -> [(String, [SGFCValueType])] {
    return [a]
 }
            if case .yy9(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy35(try codeBlockForRule11(a: a))
            }
        case 12: /* property_list ::= property(a) property_list(b) */
            func codeBlockForRule12(a: (String, [SGFCValueType]), b: [(String, [SGFCValueType])]) throws -> [(String, [SGFCValueType])] {
    return [a] + b
 }
            if case .yy9(let a) = yySymbolOnStack(distanceFromTop: 1),
               case .yy35(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy35(try codeBlockForRule12(a: a, b: b))
            }
        case 13: /* property ::= PROP_INDENT(a) prop_value_list(b) */
            func codeBlockForRule13(a: SGFToken, b: [SGFCValueType]) throws -> (String, [SGFCValueType]) {
    return (a.toIdentifierString()!, b)
 }
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 1),
               case .yy3(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy9(try codeBlockForRule13(a: a, b: b))
            }
        case 14: /* prop_value_list ::= prop_value(a) */
            func codeBlockForRule14(a: SGFCValueType) throws -> [SGFCValueType] {
    return [a]
 }
            if case .yy33(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy3(try codeBlockForRule14(a: a))
            }
        case 15: /* prop_value_list ::= prop_value(a) prop_value_list(b) */
            func codeBlockForRule15(a: SGFCValueType, b: [SGFCValueType]) throws -> [SGFCValueType] {
    return [a] + b
 }
            if case .yy33(let a) = yySymbolOnStack(distanceFromTop: 1),
               case .yy3(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy3(try codeBlockForRule15(a: a, b: b))
            }
        case 16: /* prop_value ::= OPEN_BRACKET CLOSE_BRACKET */
            func codeBlockForRule16() throws -> SGFCValueType {
    return .single("")
 }
            return .yy33(try codeBlockForRule16())
        case 17: /* prop_value ::= OPEN_BRACKET c_value_type(a) CLOSE_BRACKET */
            func codeBlockForRule17(a: SGFCValueType) throws -> SGFCValueType {
    return a
 }
            if case .yy33(let a) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy33(try codeBlockForRule17(a: a))
            }
        case 18: /* c_value_type ::= VALUE(a) */
            func codeBlockForRule18(a: SGFToken) throws -> SGFCValueType {
    return .single(a.toValueString()!)
 }
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy33(try codeBlockForRule18(a: a))
            }
        case 19: /* c_value_type ::= VALUE(a) COLUMN VALUE(b) */
            func codeBlockForRule19(a: SGFToken, b: SGFToken) throws -> SGFCValueType {
    return .compose(a.toValueString()!, b.toValueString()!)
 }
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 2),
               case .yy0(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy33(try codeBlockForRule19(a: a, b: b))
            }
        default:
            fatalError("Can't invoke code block for rule number \(ruleNumber) - no such rule")
        }
        fatalError("Can't resolve types correctly for invoking code block for rule number \(ruleNumber)")
    }

    private func yySymbolOnStack(distanceFromTop: Int) -> CitronSymbol {
        assert(yyStack.count > distanceFromTop)
        return yyStack[yyStack.count - 1 - distanceFromTop].symbol
    }

    func yyUnwrapResultFromSymbol(_ symbol: CitronSymbol) -> CitronResult {
        if case .yy23(let result) = symbol {
            return result
        } else {
            fatalError("Unexpected mismatch in result type")
        }
    }

    // Error capturing

    typealias CitronErrorCaptureDelegate = _SGFParserCitronErrorCaptureDelegate

    weak var errorCaptureDelegate: CitronErrorCaptureDelegate? = nil

    let yyErrorCaptureSymbolNumbersForState: [CitronStateNumber:[CitronSymbolNumber]] = [:]
    let yyCanErrorCapture: Bool = false
    let yyErrorCaptureDirectives: [CitronSymbolNumber:(endAfter:[[CitronTokenCode]],endBefore:[CitronTokenCode])] = [:]
    let yyErrorCaptureEndBeforeTokens: Set<CitronSymbolNumber> = []

    let yyErrorCaptureEndAfterSequenceEndingTokens: Set<CitronSymbolNumber> = []

    func yyShouldSaveErrorForCapturing(error: Error) -> Bool {
        fatalError("This parser was not generated with error capturing information")
    }

    func yyCaptureError(on symbolCode: CitronNonTerminalCode, error: Error, state: CitronErrorCaptureState) -> CitronSymbol? {
        fatalError("This parser was not generated with error capturing information")
    }

    func yySymbolContent(_ symbol: CitronSymbol) -> Any { return symbol.typeErasedContent() }

    let yyStartSymbolNumber: CitronSymbolNumber = 20
    let yyEndStateNumber: CitronStateNumber = 15

    var yyErrorCaptureSavedError: (error: Error, isLexerError: Bool)? = nil
    var yyErrorCaptureTokensSinceError: [(token: CitronToken, tokenCode: CitronTokenCode)] = []
    var yyErrorCaptureStackIndices: [Int] = []
    var yyErrorCaptureStartSymbolStackIndex: Int? = nil

    var numberOfCapturedErrors: Int = 0
}

protocol _SGFParserCitronErrorCaptureDelegate : class {
    func shouldSaveErrorForCapturing(error: Error) -> Bool
}

extension _SGFParserCitronErrorCaptureDelegate {
    func shouldSaveErrorForCapturing(error: Error) -> Bool {
        return true
    }
}

// Ability to use == to compare CitronSymbolCode with CitronTokenCode / CitronNonTerminalCode

extension SGFParser.CitronSymbolCode {
    static func == (a: SGFParser.CitronSymbolCode, b: SGFParser.CitronTokenCode) -> Bool {
        guard case let .token(code) = a else { return false }
        return (code == b)
    }
    static func == (a: SGFParser.CitronTokenCode, b: SGFParser.CitronSymbolCode) -> Bool {
        guard case let .token(code) = b else { return false }
        return (code == a)
    }
    static func == (a: SGFParser.CitronSymbolCode, b: SGFParser.CitronNonTerminalCode) -> Bool {
        guard case let .nonterminal(code) = a else { return false }
        return (code == b)
    }
    static func == (a: SGFParser.CitronNonTerminalCode, b: SGFParser.CitronSymbolCode) -> Bool {
        guard case let .nonterminal(code) = b else { return false }
        return (code == a)
    }
}

// Ability to use switch (symbolCode) { case .tokenCode: ...; case .nonterminalCode: ... }

extension SGFParser.CitronSymbolCode {
    static func ~= (pattern: SGFParser.CitronTokenCode, value: SGFParser.CitronSymbolCode) -> Bool {
        return (pattern == value)
    }
    static func ~= (pattern: SGFParser.CitronNonTerminalCode, value: SGFParser.CitronSymbolCode) -> Bool {
        return (pattern == value)
    }
}
